Through the GUI, simply click run

Or, through terminal

cd to the app
dev_appserver.py .

. is for current directory, or you can type the directory

Then visit at localhost:8080

And to deploy online:

appcfg.py update .

User: ypodeswa@gmail.com
Paswword: my Google pass (see LP, it's not a common one)

Or just use deploy in the GUI

Again, to see it deployed, go to:
http://hello-udacity-yasha.appspot.com/

To backup my app, something like:
cp app.yaml main.py index.yaml past_versions/2_PS3_blog/
cp -r templates/ past_versions/2_PS3_blog/templates/
cp -r static/ past_versions/2_PS3_blog/static/

#####################################
# Lesson 1: How the Web Works
#####################################

We'll cover
	- the web (what is it)
	- HTML (main doc type of the web)
	- URLs (how to refer to docs)
	- HTTP (protocol that the web runs on)
	- web applications

The World Wide Web
	- a collection of HTML docs
	- HTML
		- HyperText Markup Language
		- links btwn HTML = Hyper Links
	- Note that we can find many files other than HTML
		- plain text, images, pdfs, videos, etc.
	- Major pieces of the web
			1) You (your computer + browser)
				- browser = a program that displays files found on the web
				- all browsers are a bit different, none are "perfect"
				- must always keep in mind that all browsers behave differently
			2) The Internet
				- the world's largest computer network
			3) HTTP
				- the main protocol of the web
			3) Servers
				- computers that host the files that make up the web
	- So how does this all work?
		- You make requests via the internet to servers, using the HTTP protocol
		- Servers are computers optimized for sitting in a closet, hosting files

HTML basics
	- made up of:
		- text content
			- "what you see"
			- if you just enter text with zero markup, it will simpply show up as plain text
		- markup
			- "what it looks like"
			- Elements:
				<NAME>Contents</NAME>
			- tags can be nested
		- references to
			- "i.e. images and videos"
		- links to other pages
	- Example tabs:
		- bold tag
			<b>Makes stuff bold</b>
		- emphasis tag
			<em>Makes stuff italic</em>
		- anchor tag
			<a href="www.reddit.com">derp</a>
		- images tag
			<img src="url" alt="text">
				- note the two attributes, src and alt
				- definitely nice to include alt, good for broken pages and blind people
				- image tags are VOID tags
					- they have no content, so they don't need a closing tag
				- note that images just appear in line with text
	- What happens when we forget to close tags?
		- say it's an <em> tag, everything after will be italicized
		- depends on the tag/browser, though
	- Whitespace
		- in HTML all whitespace (tabs, single spaces, multiple spaces, new lines) turn into single spaces
		- BY DEFAULT, ANY AMOUNT OF WHITESPACE TURNS INTO A SINGLE SPACE
		- for example:
			this text is really
			too long for one line
		- displays as:
			this text is really too long for one line
		- if we want a new line
			this text is really
			<br>
			too long for one line
		- or a blank line between
			this text is really
			<br>
			<br>
			too long for one line
	- Other ways of doing new lines
		- paragraph tag
			<p>this text is really</p>
			<p>too long for onw linw</p>
	- Inline vs. block
		- the <br> tag is inline
			- it just ends a line
			- examples: <b>, <em>, <img>, <span>
		- the <p> tag is block
			- it creates an invisible box, with things lke a 
			- examples: <p>, <div>
		- <span> and <div> are basically inline and block versions of the same thing
			- they just contain text, but don't do anything else

HTML documents
	- Example of basic structure:
<!doctype html>
<html>
<head>
	<title>Title!</title>
</head>
<body>
	<b>content</b>
</body>
</html>

		- head contains meta-data, title, JavaScript, CSS, etc.
			- also contains the doctype
		- body contains the actual contents of the document
			- for most of this course we'll be working on generating the contents of the body tags

URLs
	- Uniform Resource Locator
	- Example:
			http://www.udacity.com/
				Protocol: http
					- could also be something like ftp
				Host: www.udacity.com
					- domain name of server that has the doc we want to fetch
					- can also just be an IP address
				Path: /
	- Query parameters
		- also called GET parameters
		- example:
			http://example.com/foo?P=1&q=neat
				- First parameter is after the ?, subsequent parameters are after the &
					- so in this case parameter P is "1", parameter q is "neat"
				- when you make a request to the server for said path, you ALSO pass this extra info
					- all sorts of handy uses for this!
	- Fragments
		- represented with a # sign
		- examples:
			http://www.example.com/foo#fragment
			http://www.example.com/foo?p=1#fragment
		- note that fragments come after query params
		- fragments ARE NOT SENT TO THE SERVER, just used on the local machine
	- Ports
		- to connect to a machine, you need the host AND the port
		- by default the port = 80, so:
			http://www.example.com/
			- Is really
			http://www.example.com:80/
		- You can also explicitly specify the port
			http://localhost:8000/
	- Final example of structure:
		http://example.com:80/toys?p=foo#blah
	- There are other parts to a url, but we won't cover them now

HTTP Requests
	- HTTP
			-HyperText Transfer Protocol
			- the main protocol of the web
				- what our browser uses to talk to web servers
	- For example, when we type:
		htttp://www.example.com/foo
		- We send this request line
		GET /foo HTTP/1.1
			- GET is the method
				- most often used for getting docs from the server
				- another popular method is POST
					- most often used for posting data to the server
			- /foo is the path
				- the actual document we're requesting
			- HTTP/1.1 is the version
				- most browser speak 1.1, but 1.0 still has a few uses
			- Note that there's no host name
				- Our browser already connected to the host
					- www.example.com was used to make this connection
				- it's just the /foo part that's making the request
	- More complex example:
		- URL
			http://www.example.com/foo/logo.png?p=1#tricky
		- GET request:
			GET /foo/logo.png?p=1 HTTP/1.1
		- Note that the path...
			- INCLUDES the query parameters
			- DOESN'T INCLUDE fragments
	- The request line is followed by a number of headers, for example:
		GET /foo?p=1 HTTP/1.1
		Host: www.example.com
		User-Agent: chrome
		- We're already connected to the server, why do we need the host?
			- Because one server can host multiple websites!
		- User-Agent is generally your browser
			- if one IP and one fake user agent is just pumelling your site, they're probably malicious
	- Valid Headers:
			Host: www.hipmunk.com
			User-Agent: Chrome
			i-made-this-up: whatever
	- Invalid headers
			User Agent: Chrome
			Host www.hipmunk.com
	- HEADERS NAMES MUST BE ALL ONE WORD, AND MUST BE FOLLOWED BY A ": "

HTTP Responses
	- Browser makes a request, server responds with a response
	- Returns docs plus...
	- Basic HTTP response:
		- Request:
			- Request line:
				GET /foo HTTP/1.1
		- Response:
			- Status line (alagous to request line):
				HTTP/1.1 200 OK
					- version status-code reason-phrase
					- Common status codes:
						- 200 OK
							- "Document was found"
							- the most common status code on the internet
						- 302 Found
							- "Document is located somewhere else"
						- 404 Not Found
							- "Document was not found"
						- 500 Server Error
							- Server broke trying to handle your request
		- Status codes start with a 1, 2, 3, 4 or 5
			- 2 = success
			- 3 = need to do something different to find this doc
			- 4 = error on the browser side (trying to request a doc that doesn't exist)
			- 5 = error on the server side
	- Status line is followed by headers
		- Example:
				HTTP/1.1 200 OK
				Date: Tue Mar 2012 04:33:33 GMT
				Server: Apache/2.2.3
				Content-Type: text/html;
				Content-Length: 1539
		- Some headers are required, some are not
			- Date is always there
			- You may not want to include the server, or to make something up
				- Why display vulnerabilities to a hacker?
			- Content type is always there
			- Content length is somewhat optional

Playing around with HTTP requests
	- Open terminal, enter:

telnet www.yashley2014.com 80

	- This is what your browser is sending when you enter the URL www.yashley2014.com (it's going to port 80)
	- Returns:

Trying 74.125.28.147...
Connected to http://www.yashley2014.com.
Escape character is '^]'.

	- Then we can include the GET request

GET / HTTP/1.0
Host: www.yashley2014.com

	- Why HTTP 1.0 and not 1.1?
		 - The default behaviour in 1.1 is to not close the connection once it's finished, which is annoying for testing
	- Returns:

HTTP/1.1 200 OK
Server: nginx/1.4.3
Date: Sun, 05 Jan 2014 01:11:31 GMT
Content-Type: text/html
Content-Length: 3110
Last-Modified: Mon, 04 Nov 2013 03:51:03 GMT
Connection: close
ETag: "527719a7-c26"
Accept-Ranges: bytes

<!DOCTYPE html>
<!-- saved from url=(0043)http://getbootstrap.com/examples/jumbotron/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
etc. (more HTML code)

	- So we see the HTTP response there at the top!
		- the status line, and a whole bunch of headers

	- What if you get a 302 error?
		- it should return a "Location" header
			- this should tell you where the document is actually located (a new URL)
		- if you do a GET request for this new URL, you *SHOULD* get a 200 response, with your doc


Servers
	- Purpose: to respond to HTTP requests
	- 2 main types of responses from servers
		1) Static
			- server returns a pre-written file
				- e.g. an image
		2) Dynamic
			- response built on the fly by the program that's running on the server
			- most sites now are built dynamically, on the fly, by web applications
	- So a web application lives on a server, gets HTTP requests, and generates documents to return to clients


#####################################
# Problem Set 1 - Creating Your First Site
#####################################

Directions:
	- Install Google App Engine (the Pythin version)
	- Put online a basic app that says "Hello, Udacity!"
	- Submit the URL to Udacity

Basically just follow directions on this page:
https://developers.google.com/appengine/?csw=1#getstarted-framework-flask

My local copy is at:
/Users/yasha.podeswa/Documents/everything_else/git_repos/appengine-django-skeleton

/usr/local/google_appengine points to the SDK, so add this to my path

Open the Google app engine app, create a new project
Mine is called "hello-udacity-yasha"
And it's located at:
/Users/yasha.podeswa/Documents/everything_else/git_repos/hello-udacity-yasha

Edit main.py so the argument here is 'Hello Udacity!'
class MainHandler(webapp2.RequestHandler):
    def get(self):
        self.response.write('Hello Udacity!')

Make the app in the online app engine console as well

Deploy with the local app engine program

Go to:
http://hello-udacity-yasha.appspot.com/

To see it deployed

Or, to run it locally:

Through the GUI, simply click run

Or, through terminal

cd to the app
dev_appserver.py .

. is for current directory, or you can type the directory

Then visit at localhost:8080

And to deploy online:

appcfg.py update .

User: ypodeswa@gmail.com
Paswword: mypass

Or just use deploy in the GUI

Again, to see it deployed, go to:
http://hello-udacity-yasha.appspot.com/


#####################################
# Office Hours 1
#####################################

Questions and Answers:

- Why Google App Engine?
	- Easiest way to get something up an running
- What is Google App Enginge
	- You just write Python code
	- You use the console or launcher to upload your app
- What are some useful things to know about front end app development?
	- Need to know HTML, CSS, JS
- Is Google App Engine a good solution for large scale projects?
	- Many people do use it in production
	- But it can get a bit expensive
	- ALSO, when we start doing things like user registration and cookies, we'll be looking at it from a general overall sense


#####################################
# Lesson 2
#####################################

Forms
	- We'll be working with the file "play.html"
	- See <form> tag in play.html

<form>
	<input name="q">
</form>

	- What happens when a user types "hello", then hits enter on the form?
	- the url changes to: play.html?q=hello

	- Let's add a submit button:

<form>
	<input name="q">
	<input type="submit">
</form>

	- creates a submit button, which is no different to submitting with enter

	- Ok, so now the form just submits to itself, which kind of sucks
	- How do we make it submit elsewhere?
		- With the "action" attribute

<form action="/foo">
	<input name="q">
	<input type="submit">
</form>

	- the action tag contains the URL where we should search to
	- for example:

<form action="http://www.google.com/search">
	<input name="q">
	<input type="submit">
</form>

	- Now queries are submitted to Google search results, and our browser re-directs there!
		- Why did this work?
			- We generated code that sent us to:
				http://www.google.com/search?q=what+we+searched
			- This is the same syntax Google search uses!
	- Why the "pluses"?
		- URLs can't have spaces in them
		- Browser did "URL encoding"
			- turns spaces into pluses
		- There are other escape characters, i.e.
			- many browsers turn ! into %21, for example

###########
Live web applications
###########

	- Let's start with the simple hello world Python example that Google has on the app engine

import webapp2

class MainHandler(webapp2.RequestHandler):
	def get(self):
		self.response.headers['Content-Type'] = 'text/plain'
		self.response.write('Hello, Udacity!')

app = webapp2.WSGIApplication([('/', MainHandler)], debug=True)

The "app = " line is the URL mapping section
	- there's one URL, "/", and it maps to the handler "MainHandler"
	- The class has a function called "get", which takes a parameter called "self" (a common parameter to many Python methods)
		- get does two things:
			1) It takes self.response, the global response object that this framework uses.  Then it sets a header, where the "Content-Type" is set to "text/plain".  By default this is set to "text/html"
			2) Then it writes the string "Hello, Udacity!"

What if we want something more interesting?  Let's replace the string with a variable that holds a string:

import webapp2

form = """
<form action="http://www.google.com/search">
	<input name="q">
	<input type="submit">
</form>
"""

class MainHandler(webapp2.RequestHandler):
	def get(self):
		self.response.headers['Content-Type'] = 'text/plain'
		self.response.write(form)

app = webapp2.WSGIApplication([('/', MainHandler)], debug=True)

But this only returns text showing the HTML, not the rendered HTML!
	- Why?  Because of the "text/html" header!
	- Comment out that line to render properly

Now lets make it submit to the server, not to Google!
	- Change the form's attribute:

<form action="/testform">

	- And also we need our app to be able to handle more than just '/'

class TestHandler(webapp2.RequestHandler):
	def get(self):
		q = self.request.get("q")
		self.response.out.write(q)

app = webapp2.WSGIApplication([('/', MainHandler),
	('/testform', TestHandler)],
	debug=True)

	- Note how we added the URL mapping for '/testform', and had it handled by TestHandler
	- BUT we had to create the TestHandler class!
		- This class:
			- Sets a variable called q, that comes from self.request
				- response is an object representing the response we'll send to the client
				- request is an object representing the request we'll get from the client
					- we can call get on it to get different parameters (in this case we're 'getting' the parameter q)
			- returns q
				- So the response will now display this variable
				- So now when we submit "hello", it will just return a page saying "hello", at the URL http://localhost:8080/testform?q=hello

- What if we change TestHandler to this, then submit?

class TestHandler(webapp2.RequestHandler):
	def get(self):
		# q = self.request.get("q")
		# self.response.out.write(q)
		self.response.headers['Content-Type'] = 'text/plain'
		self.response.out.write(self.request)

- We see the HTTP request!
GET /testform?q=hello+world HTTP/1.1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.8
Host: localhost:8080
Referer: http://localhost:8080/
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36
X-Appengine-Country: ZZ

- There's the request line, then a bunch of headers
	- The Referer header is interesting, it tells you the URL that sent the request
		- Also, Referer is misspelled :)  Happened once, kept that way for backwards compatibility
- Note that if we hadn't set the content type to text/plain, it would have looked weird
- We printed out the Python object self.request
	- This object prints to look exactly like an HTTP request

The above is a very handy debugging tool!


Ok, let's add a new method to our form, "post"
	- We do this in the HTML:

form = """
<form method="post" action="/testform">
	<input name="q">
	<input type="submit">
</form>
"""

	- the default for forms method is "get"
		- but here we can specify a different method for what will happen when you submit
	- What will happen if we submit now?
		- We get the following error message
"""405 Method Not Allowed
The method POST is not allowed for this resource."""

- Remember, 405 is the status code
	- status codes starting with 4 are errors on the browser side
	- this one means "method not allowed"
- What's wrong?
	- The handler class for /testform is TestHandler
	- This class does not have a method defining what to do with get methods
		- let's add one:

class TestHandler(webapp2.RequestHandler):
	def get(self):
		q = self.request.get("q")
		self.response.out.write(q)
	def post(self):
		q = self.request.get("q")
		self.response.out.write(q)
		# self.response.headers['Content-Type'] = 'text/plain'
		# self.response.out.write(self.request)

- Now it once again just takes us to a new page displaying our query
	- However, the URL is different!
		- instead of:
			localhost:8080/testform?q=hello
		- it's
			localhost:8080/testform
		- there's no query part!
	- How do we see what happened?

class TestHandler(webapp2.RequestHandler):
	def get(self):
		q = self.request.get("q")
		self.response.out.write(q)
	def post(self):
		# q = self.request.get("q")
		# self.response.out.write(q)
		self.response.headers['Content-Type'] = 'text/plain'
		self.response.out.write(self.request)

- And this is what we see:

POST /testform HTTP/1.1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.8
Cache-Control: max-age=0
Content-Length: 7
Content-Type: application/x-www-form-urlencoded
Content_Length: 7
Content_Type: application/x-www-form-urlencoded
Host: localhost:8080
Origin: http://localhost:8080
Referer: http://localhost:8080/
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36
X-Appengine-Country: ZZ

q=dfhhh

- So the query has been passes in the HTML request
	- after the HTTP request headers, but still part of the request
	- note also that it's a POST request, not a GET request
- Also note that some headers are printed twice
	- we're not printing the actual request, we're printing the Python representation of the request
	- it's a little glitchy

- GET vs. POST:
	- GET
		- parameters in URL
		- used for fetching documents
		- maximum URL length
		- OK to cache
			- there are lots of machines btwn you and the server
			- caching along the way saves effort
				- You can turn this off with headers, but it's generally good
		- shouldn't change the server
		- OVERALL:
			- GET requests = simple requests for fetching files
			- GET parameters should be used to describe what files to fetch
	- POST
		- parameters in body
		- used for updating data
		- no max URL length (though servers can be configured to have a max length, often a few MB)
		- not OK to cache
			- the data in them is potentially sensitive
		- OK/meant to change the server
			- POST requests are for updating the server
			- POST requests are generally destructive in nature

- What if you don't use these requests as you should?
	- Case study: Base Camp, back in the day
		- you used to see a page with task, and a bunch of "Delete" options beside them
			- clicking delete would remove the item
		- the delete options were HTML links
			- automatically GET requests!
			- POST is for forms, not links
		- There was also another program, Google web accelerator
			- This was a browser extension
			- It would pre-load all links, so they're "ready to go" when you click on them
				- It would pre-load the delete links, and delete all your items!
	- So really these "delete" buttons should have been forms, not links

- Back to playing around with static html
	- simple form

<form>
	<input type="text" name="q">
	<input type="submit">
</form>

- Submit "some junk", will load the same page with the following URL:
file://localhost/Users/yasha.podeswa/Documents/everything_else/git_repos/coding_notes/Udacity/Web_Development_Course/play.html?q=some+junk

- So just adds the query parameter to the URL
	- the type="text" attribute is optional, it's the default
- Let's try other types!
	- type="password"
	- the URL is the same, but text typed in the in input appears as documents
- Key takeway:
	- the password is not sent securely to the server here, it's sent like any other parameter

- type="checkbox"
	- adds ?q=on if the box is checked when you hit submit
	- else simply adds ?
		- the q parameter doesn't appear at all
	- however, not all browsers behave the same
		- best practice when writing server side scripts:
			- treat q=on as checked
			- treat ANYTHING ELSE as off, just in case
	- what if there are a few checkboxes?

<form>
	<input type="checkbox" name="q">
	<input type="checkbox" name="r">
	<input type="checkbox" name="s">
	<br>
	<input type="submit">
</form>

- If you check the first two, the query section (after the ?) of the URL will be:
q=on&r=on

- Note how the parameters are separated by "&"

- type="radio"
	- by default, identical to checkboxes, EXCEPT they can't be unchecked
		- NOT how you'd expect them to perform!
		- how to make them perform as a group, so that only one can be selected at a time?
			- give them all the same name!

<form>
	<input type="radio" name="q">
	<input type="radio" name="q">
	<input type="radio" name="q">
	<br>
	<input type="submit">
</form>

- This makes sense, as only one can be on, no need for multiple names
	- BUT no matter which button you select, q=on
	- How do we know what button was selected?
		- the value parameter!

<form>
	<input type="radio" name="q" value="one">
	<input type="radio" name="q" value="two">
	<input type="radio" name="q" value="three">
	<br>
	<input type="submit">
</form>

- Click the second, submit, and:
q=two
- So it changes the value of the query parameter!

- Ok, so right now we have 3 annonymous radio buttons
	- How do we let the user know what they're clicking on?

<form>
	<label>
		One
		<input type="radio" name="q" value="one">
	</label>

	<label>
		Two
		<input type="radio" name="q" value="two">
	</label>

	<label>
		Three
		<input type="radio" name="q" value="three">
	</label>

	<br>
	<input type="submit">
</form>

- Will add labels in front of the radio buttons

- Lastly, let's look at how to do dropdown form elements:

<form>
	<select name="q">
		<option>one</option>
		<option>two</option>
		<option>three</option>
	</select>

	<br>
	<input type="submit">
</form>

- will give a dropdown
	- selecting the third item and hitting submit will give you:
q=three

- note how it's just the contents of the option tag
	- what if you want a different param passed?
		- use the value parameter!

<form>
	<select name="q">
		<option value="1">one</option>
		<option value="2">two</option>
		<option value="3">three</option>
	</select>

	<br>
	<input type="submit">
</form>

- will return:
q=1


#########
Validation
#########

- Idea - verify on the server side that we received what we expected to received
	- i.e. you're sending q=on
		- that's fine, server knows what to do
	- but what if you send q=broken, and our server doesn't know what to do with it?
		- even if the checkbox can't send this, it doesn't mean that users can't send arbitrary junk to our servers through other means
- Basically, your server can receive junk, and your server needs to know how to deal with it


- Example: back to the live web app
	- I'm not going to take notes on everything, just copy the code
	- Inspect the code to see what happens

- Quiz:
# Write a function valid_month() to verify 
# whether the data a user enters is a valid 
# month. If the passed in parameter 'month' 
# is not a valid month, return nothing. 
# If 'month' is a valid month, then return 
# the name of the month with the first letter 
# capitalized.

months = ['January',
	'February',
	'March',
	'April',
	'May',
	'June',
	'July',
	'August',
	'September',
	'October',
	'November',
	'December']

month_abbvs = dict((m[:3].lower(), m) for m in months)
# What this says is:
#   - we're creating a new dictionary
#   - for m in month (i.e. it will be 'January', then 'February', etc.)
#   - we'll create a dictionary where the keys are a substrings of the first 3 characters, to lower
#   - and the values are the original strings
# print month_abbvs

# If we weren't using the abbreviations:
# def valid_month(month):
# 	if month:
# 		cap_month = month.capitalize()
# 		if cap_month in months:
# 			return cap_month

# Using the abbvs:
def valid_month(month):
	if month:
		short_month = month[:3].lower()
		return month_abbvs.get(short_month)
# The get method of a Python dictionary first checks if the key is in the dict
#   - if it is, it'll return the value

print valid_month('JAN')					# January
print valid_month('JANuary')			# January
print valid_month('Jannnnnnnny')	# January
print valid_month('blah')					# None


# Ok, now let's do the same for days
# My solution:
def valid_day(day):
	if day:
		try:
			day_num = int(day)
		except ValueError:
			day_num = None
		if day_num:
			if day_num >= 1 and day_num <= 31:
				return day_num

# Their solution
def valid_day(day):
	if day and day.isdigit():
		day = int(day)
		if day > 0 and day <= 31:
			return day

# However, I think their solution will only work if passed strings
#  - .isdigit() is a method for strings
#  - if passed a number, you got problems

# Now to test for a valid year, which we'll say is between 1900 and 2020

def valid_year(year):
	if year and year.isdigit():
		year = int(year)
		if year > 1900 and year < 2020:
			return year

- How will these functions fit in?
	1) User makes GET request for the form
	2) Server responds with form data
	3) User makes POST request with the data
	4) Server runs valudation function
		- if data is good, server says thanks
		- if data is bad, re-send form data + error message

- So 3 things we have to do:
	1) Verify the user's input
	2) On error, render form again
	3) Include error message

# String substitution in Python
a = "hello"
print("<b> %s </b>" % a)
# prints: <b> hello </b>

# Another example:
t1 = "I think %s is a perfectly normal thing to do in public."
def sub1(s):
	return t1 % s
print sub1("running") 
# => "I think running is a perfectly normal thing to do in public."    

# Or to substitute multiple strings
t2 = "I think %s and %s are perfectly normal things to do in public."
def sub2(s1, s2):
	return t2 % (s1, s2)
print sub2("running", "sleeping") 
# => "I think running and sleeping are perfectly normal things to do in public."

# Finally, even more complex
#		Instead of stacking tonnes of %s, then %(s1, s2, s3, etc.)
#		We can use names and dictionaries
"test %(NAME)s text" % {"NAME": value}
# The name can appear in the string multiple times, and we can have multiple names

# Example
t3 = "I'm %(nickname)s. My real name is %(name)s, but my friends call me %(nickname)s."
def sub_m(name, nickname):
	return t3 % {"name": name, "nickname": nickname} 
print sub_m("Mike", "Goose") 
# => "I'm Goose. My real name is Mike, but my friends call me Goose."

# Ok, so we've integrated the above
# 	We now have a form that's showing an error message when you input the wrong data
# 	But it would be nice to keep the correct data!
# Let's look at default values:
<input type="text" value="cool">

# So for perserving a correct month, we'd do something like:
<input type="text" name="month" value="%(month)s">

- What about weird input?
	- For example, say someone enters foo">derp as the month
	- We'll be substituting this into the input tag's value attribute
		- So we'll get:
		<input value="foo">derp">
		- the string will be cut off, and it will be followed by derp">
			- Not what we want!
		- And what if instead of derp, they put in some malicious shit!

- How to fix this?  Escaping!
	- instead of returning ", we return &quot;
	- also:
		>		&gt;
		<		&lt;
		&		&amp;

- My escape html function:
def escape_html(s):
	terms = {
		">": "&gt;",
		"<": "&lt;",
		'"': "&quot;",
		"&": "&amp;"
	}
	l = list(s)
	output = []
	for c in l:
		if c in terms:
			output.append(terms[c])
		else:
			output.append(c)
	return "".join(output)

- Their solution:
def escape_html(s):
	for (i, o) in (("&", "&amp;"),
									(">", "&gt;"),
									("<", "&lt;"),
									('"', "&quot;")):
		s = s.replace(i, o)
	return s

- Or even simpler
import cgi
def escape_html(s):
	return cgi.escape(s, quote = True)


- Redirection
	- OK, so up to now our "success" doesn't send you to a new page
		- This is annoying because you can't share the link
		- You also can't refresh without an annoying message
	- Instead of returning the success HTML, we should return a redirect!
		- The server sends the redirect, then when we hit the new page we send a GET request, then we get the success HTML

- Optimal form behaviour
	- Keep re-serving the form until the user enters valid info
	- Once you get valid input, redirect them to a success page

- What we need to do:
	- make a "thanks" handler
	- add the /thanks URL
	- redirect to the /thanks URL

- In this case:
	- the post method of the main handler will redirect to /thanks when it gets valid data
	- the thanks handler will write our success message when it gets a GET request
	- finally, we must map '/thanks' to the ThanksHandler

###########
# Our app so far
###########

import webapp2
import cgi

months = ['January',
	'February',
	'March',
	'April',
	'May',
	'June',
	'July',
	'August',
	'September',
	'October',
	'November',
	'December']

month_abbvs = dict((m[:3].lower(), m) for m in months)

def valid_month(month):
	if month:
		short_month = month[:3].lower()
		return month_abbvs.get(short_month)

def valid_day(day):
	if day and day.isdigit():
		day = int(day)
		if day > 0 and day <= 31:
			return day

def valid_year(year):
	if year and year.isdigit():
		year = int(year)
		if year > 1900 and year < 2020:
			return year

def escape_html(s):
	return cgi.escape(s, quote = True)

form = """
<form method="post">
	What is your birthday?
	<br>
	
	<label> Month
		<input type="text" name="month" value="%(month)s">
	</label>
	
	<label> Day
		<input type="text" name="day" value="%(day)s">
	</label>

	<label> Year
		<input type="text" name="year" value="%(year)s">
	</label>

	<div style="color: red">%(error)s</div>

	<br>
	<br>
	<input type="submit">
</form>
"""

class MainHandler(webapp2.RequestHandler):
	def write_form(self, error="", month="", day="", year=""):
	# We will be calling this instead of:
	# self.response.out.write(form)
	# Because it let's us substitute in error messages
		self.response.out.write(form % {"error": error,
			"month": escape_html(month),
			"day": escape_html(day),
			"year": escape_html(year)})

	def get(self):
		self.write_form()

	def post(self):
		user_month = self.request.get('month')
		user_day = self.request.get('day')
		user_year = self.request.get('year')

		month = valid_month(user_month)
		day = valid_day(user_day)
		year = valid_year(user_year)

		if not (month and day and year):
			self.write_form("That doesn't look valid to me, friend.",
				user_month, user_day, user_year)
			# We've used our error message!
		else:
			self.redirect("/thanks")

class ThanksHandler(webapp2.RequestHandler):
	def get(self):
		self.response.out.write("Thanks! That's a totally valid day!")

app = webapp2.WSGIApplication([('/', MainHandler),
	('/thanks', ThanksHandler)],
	debug=True)

##########
# End of app
##########


#####################################
# Problem Set 2
#####################################

- Make a site to ROT13 some text
	- ROT13 is a simple encryption algorithm, where you increment every letter by 13
	- Running it through twice should convert it back to the same word
	- It should:
		- preserve case
		- preserve punctuation
		- preserve whitespace (including new lines)

- Example at:
udacity-cs253.appspot.com/unit2/rot13

##########
# My solution
##########

import webapp2

def escape_html(text):
	html_escape_table = {"&": "&amp;", '"': "&quot;", "'": "&apos;", ">": "&gt;", "<": "&lt;"}
	return "".join(html_escape_table.get(c,c) for c in text)

doc = """
<!DOCTYPE html>
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Unit 2 Rot 13</title>
	<style type="text/css"></style>
</head>

<body style="">
	<h2>Enter some text to ROT13:</h2>
	<form method="post">
		<textarea name="text" style="height: 100px; width: 400px;">%(text)s</textarea>
		<br>
		<input type="submit">
	</form>
</body>
</html>
"""

class MainHandler(webapp2.RequestHandler):
	def write_form(self, text=""):
		self.response.out.write(doc % {"text": escape_html(text)})

	def rot13(self, s):
		transformed = ""
		for c in s:
			if c.isalpha():
				if c.isupper():
					c = c.lower()
					transformed += self.switch(c).upper()
				else:
					transformed += self.switch(c)
			else:
				transformed += c
		return transformed

	def switch(self, c):
		first = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m"]
		last = ["n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
		if c in first:
			return last[first.index(c)]
		else:
			return first[last.index(c)]

	def get(self):
		self.write_form()

	def post(self):
		user_input = self.request.get('text')
		transformed = self.rot13(user_input)
		self.write_form(transformed)

app = webapp2.WSGIApplication([('/', MainHandler)],
	debug=True)



#####################################
# Lesson 3: Databases
#####################################

- Databases are quite complex
	- We'll split the lesson into 2 parts:
		- 1) We'll talk about SQL
		- 2) We'll talk about Google App Engine's implementation

- What is a database?
	- A program that stores and retreives data
		- Particularly large amounts of structured data
	- Note that databases are often stored on a separate server, or even a system of servers
		- So sometimes "database" refers not to the program, but to the machine or system of machines
		- Same as how "web server" could refer to a program/machine/system of machines

- Tables
	- In almost all databases
	- Example: building a site like reddit
		- users post links
		- other users can vote on links
		- they show what's most popular
	- Tables:
		- Links
			- Columns (type):
				- ID (int)
				- votes (int)
				- user (int)
				- date (date)
				- title (str -> could also be called "text", "varchar", etc.)
				- url (str)
	- Let's play around with link type data in Python!
		- See play.py for how we played around with this data in Python
		- Note that it's a bit tedious, and a db could make it easier!

- Why databases?
	- downsides of querying by hand
		- error prone (have to custom write every query)
		- tedious
		- SLOW
		- can handle more data than you can fit in memory

- Types of databases
	- Relational/SQL databases
		- Examples:
			- PostgreSQL
				- Used by reddit, hipmunk, etc.
			- MySQL
				- Used by almost everyone
			- SQLite
				- Light weight, simple db
			- Oracle
	- Google App Engine's Datastore
		- Lots of similarities to relational DBs, but also some differences
	- Amazon Dynamo
		- See their paper
	- NoSQL
		- e.g. mongo, couch
		- try to solve some of the limitations that SQL places on you

- SQL
	- Structured Query Language
	- invented in the 1970s
		- designed to solve pre-web problems
	- basic query:
		SELECT * FROM links WHERE id = 5;
	- "fetch all columns from the links table, and return only rows where the id is 5"

- We'll be playing around with SQL by using import sqlite3
	- this lets us use SQL in Python
	- see play.py

- Joins
	- I know how they work
	- But he uses different syntax:
		- For example, say we have a user table and a link table
		- We only know the users name (in the user table, but not the link table)
		- We want all data from the link table for this user
		SELECT link.* FROM link, user WHERE link.user_id = user_id AND user.name = 'Spez'
	- HOWEVER, we don't use joins often when writing web applications
		- We'll get into why later (they're slow?)

- Indexes
	- So far we've been doing sequential scans
		- i.e. looking through a link from left to right
		- This is slow with a lot of data
	- Indexes make lookups faster
		- Example: hash tables
			- We hash and index the value of the key, so we don't have to look up the keys sequentially
	- See play.py for indexing examples
		- From the add_new_link(link) function, we can see that there's a cost to having indeces
			- Though they make lookups faster, they also make extra work when you're adding new rows
			- Faster reads, slower inserts (and generally slower writes in general, even when updating data)
	- Example of creating an index:
		CREATE INDEX hotel_id ON hotels(id);
		- We've named the index hotel_id, it's created on the hotels table, and specifically on the id field
	- To get rid of an index:
		DROP INDEX hotel_id;
	- PostgreSQL
		- EXPLAIN ANALYZE
			- Just throw that in front of a query, and it'll say what it did!
			- You can see how much faster queries run on indexed fields

- Indexes for sorting
	- hastables are not sorted
		- you lose sorting info when you use a hashtable
	- trees are a different datastructure, a different type of mapping
		- tress are sorted!
		- however, the lookups are slower
	- hashtables have constant time lookups
		- not really dependent on the number of elements in the table
	- trees have log n time lookups

- Reddit Hotness Algorithm
	- computed using a special index
	- start with the link table
		- one of the fields is 'score'
			- it's a floating point field
			- there's an index on this field
		- every time there's an up or down vote, the score is re-calculated
			- score = hot(ups, downs, date)
			- why is date in there?
				- later (newer) date = higher score
				- this is what keeps the newest links near the top!
	- then you can just:
	SELECT * FROM links ORDER BY score DESC
	- to get the links ordered with the hotest ones at the top!
	- note that this would be a tree type index
		- the db actually keeps the records ordered in order of Hotness
		- this makes it super fast to pull them out in the right order

- Scaling Databases
	- Why would you need to scale a DB?
		1) Too much load
			- a single machine can't keep up with all the requests
			- one solution:
				- replicate the db
				- all writes go to a single master db
				- this db gets replicated accross two slave DBs
				- now we have 3 dbs with all the data on it
					- more machines to handle the requests!
				- you generally have a lot more reads than writes
					- as long as master can keep up with the writes, the slaves can just handle the reads
				- downsides:
					- doesn't increase write speed
					- replication lag
						- what if you try to read the data from the slave before its been uploaded!
		2) Too much data
			- you literally cannot store all the data on one machine
			- one solution: shard the db
				- one db holds links 1-100, the next holds 101-200, etc.
				- or you can use a hashing approach, where you hash on a specific key (i.e. link ids)
			- also solves the "too much load" issue, as you now have a lot of machines sharing the load
				- can handle large read load AND large write load!
			- downsides:
				- queries get much more complex
					- i.e. what if you try to get all the links sorted by hotness!
						- where do they reside?
						- you have to do a range query, which hits all the machines, you lose the 
				- joins becomes difficult, or even impossible
				- you probably need to design your data in a way that you don't need to do joins or complex queries
				- the database we'll be using in this class (Google Data Store) is like this:
					- we can't do joins, and a number of other things
					- BUT it's very fast and stable

- ACID
	- Stands for:
		- Atomicity
			- all parts of a transaction succeed or fail together
			- transaction = group of statements
			- i.e. say we're updating multiple rows in a db together, in one cohesive unit (i.e. in reddit example, we'd increase the score of the link and user together)
			- so these grouped jobs always succeed or fail together
		- Consistency
			- the DB will always be consistent
			- i.e. the db will always move from one valid transaction to the next
			- so, for example, you can't read a specific piece of data until the write on that data is done
		- Isolation
			- no transaction can interfere with another
			- i.e. say you have an upvote and a downvote
			- you should make sure they BOTH apply, not just one with the other failing
		- Durability
			- once a transaction s committed, it won't be lost
				- even if the db is turned off, unplugged, etc. we won't lose the data
	- It's hard to have a DB that really fulfils all of this

- Google App Engine Datastore
	- what they call 'entities' are basically tables
		- columns are not fixed
			- adding/changing them is easy
			- even entities of the same type don't have to have the same columns
				- sometimes adding columns to dbs with lots of data is hard, with app engine it isn't
		- entities all have an ID
		- entities have parents/ancestors
			- these are relationships to other entities
			- say we have an entity called Link
			- It might have a parent called Reddit
				- You can do things like "get me all Links that are children of Reddit"
				- can help with consistency
	- uses GQL instead of SQL
		- all queries begin with SELECT *
			- no way to select columns
		- no joins
		- all queries must be indexed
			- for the most part, Google App Engine will build the indeces for you, though you can define your own too
	- can use a procedural language instead of GQL if you want
	- the datastore is sharded and replicated
		- you won't have to think about scaling (too much)
		- queries will be quick (because they have to be simple)
		- we WILL have to think about consistency
			- because things are sharded/replicated, so updates can take time to fully propogate through the system
	- Check out the documentation here, no need to learn everything first:
		https://developers.google.com/appengine/docs/python/storage

- We're going to build a website, right now, called 'ASCII Chan'
	- it'll be a website for sharing ASCII art
	- a 1 page site
	- a form on top to submit ASCII art, with some previously submitted ASCII art below

**** Next bunch of lessons - just me working on ascii_chan!

- Google App Engine Datastore Types:
	Integer
	Float
	String (<500 chars, indexed)
	Text (>500 chars, can not be indexed.  Can't say "get me stuff where Text = x")
	Date
	Time
	DateTime
	Email
	Link
	PostalAddress
	etc.

- HTML <pre> tag
	- like <div>, but contains pre-formatted text
	- basically, preserves whitespace, newlines, etc.


#####################################
# Problem Set 3 - Building a Basic Blog
#####################################
- Front page that lists entries (can list all, or 10 most recent)
- Form to submit new entries
	- must check for errors, to make sure both fields (title and content) are there
- If successful, should re-direct to a permalink page for a specific entry
- Example:
udacity-cs253.appspot.com/blog
# dispalys the content
udacity-cs253.appspot.com/blog/newpost
# for a form to enter new posts, with error handling

- Then submit blog url to udacity site


#####################################
# Problem Set 3 - Office Hours
#####################################
- MySQL vs. Postgres
	- Very similar, use whatever you like
- Why NoSQL?
	- Don't have to think everything through in advance
		- Don't have to pre-define all columns
		- Very hard to make changes to SQL dbs when you have a tonne of users (adding new columns, indexes, new data types)
		- No schema needed in NoSQL - no formal description of columns and data types
	- BUT a lot of these schema-less dbs are just not very good at the moment
		- limited stability, documentation lacking
	- For now, probably easier to just stick with MySQL/Postgres
- Why does Facebook use NoSQL?
	- FB uses a lot of MySQL actually!
	- FB used to use Cassandra, but I don't think they do anymore
- You can actually sort of do schema-less behavious in Postgres!
	- Just store one column as a big wad of JSON
- Why should we avoid joins?
	- They don't scale very well
		- Very difficult to handle accross multiple machines
	- Better to structure your data so everything is independent
		- Think of your dbs as large key-value stores
	- This DOES mean storing redundant data!
		- Storing things in multiple places
		- For example, on reddit they store a users karma on a link they submit, so they don't have to look it up
		- This means a bit more overhead, BUT easier scaling
	- For Hipmunk they do joins
		- only ~300K hotels, not that large
	- For reddit they don't
		- joining tables with billions of rows each = bad idea!


- Fancy Python syntax:

# What does this mean?
def foo(*a):
# "take all of the un-named arguments, and store them in a tuple"
# Don't have to pre-define the number of args!

def foo(*a):
	return a

foo()							# returns ()
foo(1, 2, 3)			# returns (1, 2, 3)

def foo(*a):
	return a[0]

foo(1, 2, 3)			# returns 1


# What about this?
def render(self, template, *a, **kw):
	t = jinja_env.get_template(template)
	return t.render(*a, **kw)
# the *a is for un-named arguments, i.e. 1
# 	Will be represented as a tuple IN THE FUNCTION DEFINITION
# the **kw is for named arguments, i.e. x = 1
# 	Will be represented as a dictionary IN THE FUNCTION DEFINITION
# BUT IN THE FUNCTION CALL, these tuples/dicts will be boken apart into function parameters!
# Not that *a and *kw don't have to be used, but it's a convention
# 	Sometimes also *args and **kwargs
# See here for more:
http://stackoverflow.com/questions/287085/what-do-args-and-kwargs-mean


- Web frameworks:
	- What do they do?
		- The piece of your program that:
			- speaks HTTP
			- parses URLs into paths/queries
			- passes things to handler functions
		- Something like django also does sessions, user handling, form control, etc.
			- can be good or bad
		- Ruby on Rails is very popular for Ruby
			- similar to django in that it does a lot for you
		- Google App Engine's is a bit more simplistic
	- Explain .yaml files
		- They're config files used in app engine
		- Says what libraries to load, what files to load first, etc.


- Project management
	- How to keep your code manageable?
		- Good to have one directory with all templates
		- Another dir with static files (CSS, JS, etc.)
	- In terms of Python files:
		- Good to have one main file that's the control
			- URL mapping, and the classes that the URLs map to
		- All of the database stuff in separate files
			- i.e. the classes that create dbs
		- Also good to have utilities files
			- For generating random strings, hash values, etc.
	- Generally good to pull things apart into lots of small, clean files
		- In this class, though, we've been jamming a lot into one file
		- Easier for a small project, bad for a big one


#####################################
# Lesson 4: User Accounts and Security
#####################################
- Gonna learn about:
	- cookies
	- hashing paswords, storing them securely

- Cookies
	- small file/piece of data stored in the browser for a website
	- takes this sort of form:
		name = value
		i.e. user.id = 12345
	- used a lot to store temporary info:
		- i.e. whether or not you're logged into a website
	- How they work:
		- browser makes request to website
		- server sends stuff back, including cookie
		- every time you visit website in the future, you send cookie data back to the server
	- Generally you can store:
		- ~20 cookies/site
		- cookies < 4kb (should be way smaller)
		- should generally not be multi-line
	- Cookies can only be stored for one domain
		- i.e. udacity.com can only store udacity.com cookies
		- this is really important, don't want other sites fucking around with your cookies, as they could then login as you on a different site!
			- all of this is enforced on the browser side
	- For SMALL pieces of TEMPORARY data, cookies can be a better place to store things than in a db
	- Good uses:
		- sotring login info
		- storing small amounts of temporary data to avoid hitting db
		- tracking you for ads
	- Bad uses:
		- storing user preference info
			- why bad?  Because it's temporary!  You want this data to survive!

- Cookie Headers
	- HTTP response (from server to user)
		- Cookies are sent in HTTP headers
		- The server's HTTP response will look something like this:
			Set-Cookie: user_id=12345
		- name is generally short, value can be up to 4kb
		- You can also set multiple cookies like this:
			Set-Cookie: user_id=12345
			Set-Cookie: last_seen=Dec 25 2011
	- HTTP request (from user to server)
		- Again in the header:
			Cookie: user_id=12345; last_seen=Dec 25 2011
		- Note how the browser puts everything into one line, separated by semi-colons
			- Thus generally easiest to avoid semi-colons in your cookies

- Let's use telnet again to check out cookies!
telnet www.google.ca 80
GET / HTTP/1.0
Host: www.google.ca
# hit return twice

- Get a massive response like this:
HTTP/1.0 200 OK
Date: Sat, 15 Feb 2014 23:56:09 GMT
Expires: -1
Cache-Control: private, max-age=0
Content-Type: text/html; charset=ISO-8859-1
Set-Cookie: PREF=ID=e2b0eee34fe24b49:FF=0:TM=1392508569:LM=1392508569:S=tO0H8uQB6MBqalKP; expires=Mon, 15-Feb-2016 23:56:09 GMT; path=/; domain=.google.ca
Set-Cookie: NID=67=gNsrj73VPiAvUdMsZoewx15k2vVacHPLB1DlufhOrIWO3QuVGiwxc2vdo_bx-tzv2QMY31RJ05MSAp1A-O3CrSBZRG8mBswjwazVjeoddtc-EAIvfPmUFg2_VDDicmgM; expires=Sun, 17-Aug-2014 23:56:09 GMT; path=/; domain=.google.ca; HttpOnly
P3P: CP="This is not a P3P policy! See http://www.google.com/support/accounts/bin/answer.py?hl=en&answer=151657 for more info."
Server: gws
X-XSS-Protection: 1; mode=block
X-Frame-Options: SAMEORIGIN
Alternate-Protocol: 80:quic

<!doctype html><html itemscope="" itemtype="http://schema.org/WebPage"><head><meta itemprop="image" content="/images/google_favicon_128.png"><title>Google</title><script>(function(){
window.google={kEI:"m
etc.

- We can see the cookies in there!  Let's take a deeper look at the first one:
Set-Cookie: PREF=ID=e2b0eee34fe24b49:FF=0:TM=1392508569:LM=1392508569:S=tO0H8uQB6MBqalKP; expires=Mon, 15-Feb-2016 23:56:09 GMT; path=/; domain=.google.ca
- One interesting thing, Google is storing multiple pieces of data in one cookie
	- name: PREF
	- value: ID=e2b0eee34fe24b49:FF=0:TM=1392508569:LM=1392508569:S=tO0H8uQB6MBqalKP
- Then after the ;, we have some parameters:
expires=Mon, 15-Feb-2016 23:56:09 GMT; path=/; domain=.google.ca
- So we see when it expires, and that it's relevant only to .google.ca/

- Let's look at the other cookie
Set-Cookie: NID=67=gNsrj73VPiAvUdMsZoewx15k2vVacHPLB1DlufhOrIWO3QuVGiwxc2vdo_bx-tzv2QMY31RJ05MSAp1A-O3CrSBZRG8mBswjwazVjeoddtc-EAIvfPmUFg2_VDDicmgM; expires=Sun, 17-Aug-2014 23:56:09 GMT; path=/; domain=.google.ca; HttpOnly
- name: NID
- value: 67=gNsrj73VPiAvUdMsZoewx15k2vVacHPLB1DlufhOrIWO3QuVGiwxc2vdo_bx-tzv2QMY31RJ05MSAp1A-O3CrSBZRG8mBswjwazVjeoddtc-EAIvfPmUFg2_VDDicmgM
- parameters:
expires=Sun, 17-Aug-2014 23:56:09 GMT
path=/
domain=.google.ca
HttpOnly
- The last bit means this cookie is relevant only to HTTP

- Another way to get just the headers:
curl -I www.google.ca

- Easier than telnet :)

- One last way to inspect cookies
	- Go into incognito mode so you don't have any existing cookies
	- go into dev tools
		- CMD-OPT-i
	- click network
	- now get surfing!
		- go to google.ca
		- now you can see all the requests!
			- click on one to see it
			- you can see both the response and request headers!
		- if you didn't have a cookie to start with, you will if you visit the same site again!

- Cookie parameters
	- e.g.:
Set-Cookie: name=steve; domain=www.reddit.com; path=/
- Note that path means "path starts with"
	- so this could apply to www.reddit.com/whatever
- This cookie will be sent to any domain ENDING in www.reddit.com.  Examples:
	www.reddit.com
	foo.www.reddit.com
- Won't be sent to:
	reddit.com
	foo.reddit.com
- You need at least two periods:
	- So you must at least set:
		.reddit.com

- Setting cookies:
	- When you send a cookie from:
		www.reddit.com
	- The default domain is:
		www.reddit.com
	- And you can only set to this domain or higher, e.g.:
		www.reddit.com
		.reddit.com
	- But not something like:
		foo.reddit.com

- Receiving cookies:
	- Which domains would receive the cookie set like this?
		Set-Cookie: user=123; Domain=ide.udacity.com
	- Would receive it:
		- ide.udacity.com
		- other.ide.udacity.com
		*** so the domain and sub-domains can receive it
	- Wouldn't receive it:
		- udacity.com
		- other.udacity.com

- Setting cookies (2):
	- Which domains could set this cookie?
		Set-Cookie: user=123; Domain=ide.udacity.com
	- Can set it:
		- ide.udacity.com
		- other.ide.udacity.com
		*** so the domain and sub-domains can set it
	- Can't set it:
		- udacity.com
		- other.udacity.com

- Browser settings:
	- We can do things like:
		- accept all cookies
		- accept cookies for the current session only
		- block all cookies
		- block 3rd party cookies
			- i.e. if I'm on reddit, ALLOW reddit cookies, but BLOCK google cookies!
	- For yourself, often good to block 3rd party cookies

- Ad Networks:
	- How they work:
		- Your browser makes a request to a website
		- The server responds to the HTML
		- IN THE RESPONSE IS A 1px IMAGE!
			- This image makes a request to a different server, i.e. google.com
			- google.com responds with the image itself, and with a cookie!
		- Worth noting that this will be a google.com cookie
			- udacity can't set it, but google can!
			- this is a 3rd party cookie
	- This could be used for Google analytics, but also for ad network tracking!
		- now Google knows that you've been to reddit.com
		- say you now visit pets.com
			- pets.com returns HTML and a tracking pixel
		- now Google knows you've been to both reddit.com and pets.com
		- So now they can deliver ads that are more relevant to you

- Cookie expiration
	- If you just set a cookie like this:
		Set-Cookie: user=123
	- It's a "session cookie"
		- Will expire when the browser is closed
	- If you want it to persist:
		Set-Cookie: user=123; Expires=Tue, 1 Jan 2025 00:00:0 GMT
	- So when you see those logins with "remember me" check-boxes
		- If you check it, you get an expires parameter
		- Else it's a session cookie, gets deleted when you close your browser

- Using cookies with app engine!
*** See app engine code

- We can set and play with cookies like this:

class BlogHandler(Handler):
	def get(self):
		# app engine automatically parses cookies, and throws them into a dictionary-like object, "cookies"
		# we can call the dict-version of get on it:
		visits = self.request.cookies.get('visits', 0)
		# get's the value of 'visits' if it's there, else 0
		# So if I've never if I've never been here before, this starts at 0
		# Now increment:
		if visits.isdigit():
			visits = int(visits) + 1
		else:
			visits = 0
		# Now set this in the cookie:
		self.response.headers.add_header('Set-Cookie', 'visits=%s' % str(visits))
		# Now use it
		if visits > 25:
			self.write("You are the best ever!")
		else:
			self.write("You've been %s times!" % visits)

- Hashing
	- What is a hash?
		H(x) -> y
	- A hash takes in x (data) of any size
	- A hash outputs a value y, which is a fixed length string
		- generally 32-256 bits
	- It should be super hard to generate a specific y
	- Likewise, it should be super hard to find x from a given y
	- You shouldn't be able to modify x without significantly modifying y
		- changing 1 bit in x should make y completely different
			- very little corellation between x and y

- Hash algorithms
	- don't write your own!
		- at least for security purposes
	- Some popular algorthms:
		- crc32
			- used for checksums
			- very fast
			- a simple way to check that you've got the whole file
				- send the file and the hash, then make sure that the file hashes to the hash
			- not for security
			- definitely possible for two values to hash to the same value
				- easy to have these "collisions"
		- md5
			- pretty fast
			- used to be thought to be pretty secure
				- BUT it's been broken repeatedly over the last few years
				- it's also now easy to find collisions
					- given a y, it's easy to find a different x that hashes to it
		- sha1
			- not quite as fast
			- pretty secure, just now starting to get broken
			- just starting to find collisions
		- sha256
			- slower
			- quite secure right now

- We'll be using sha256

- Playing around with python in the terminal
python
import hashlib
x = hashlib.md5("foo!")
x
x.hexdigest()
# gives us the string that "foo!" hashes to
# for foo! it's:
# 35af8b7a9490467f75f19c1e5459f7e7
# for foO! it's:
# 4a037b06903e4b4c6605785aebbe709a
# Totally different!

- for sha256, exactly the same, but just replace md5 with sha256

- Hashing cookies:
	- We want to prevent people from "cheating"
		- i.e. modifying their own cookies, sending us back fake data
	- Instead of just saying:
Set-Cookie: visits=5,[hash of 5]
	- now the user can't fake it without knowing what hash we used!
	- then when we get a value from the browser, like:
	5,absdfsghdfh3984237423894
	- we can hash 5, and make sure it's the same as the hash!
		- if it doesn't, we know the cookie is invalid and we can throw it out

- Implement a function make_secure_val(s)

import hashlib

def hash_str(s):
	return hashlib.md5(s).hexdigest()

def make_secure_val(s):
	return "%s,%s" % (s, hash_str(s))

- Now make a function to check if this is correct!
	- it should return the value if it's correct, else return None

def check_secure_val(h):
	val = h.split(',')[0]
	if h == make_secure_val(val):
		return val

- Now let's use these functions in our program!

# Handler for the page displaying posts
class BlogHandler(Handler):
	def get(self):
		# self.render_blog()
		self.response.headers['Content-Type'] = 'text/plain'
		visits = 0
		visits_cookie_str = self.request.cookies.get('visits')
		if visits_cookie_str:
			cookie_val = check_secure_val(visits_cookie_str)
			if cookie_val:
				visits = int(cookie_val)

		visits += 1

		new_cookie_val = make_secure_val(str(visits))

		self.response.headers.add_header('Set-Cookie', 'visits=%s' % new_cookie_val)

		if visits > 25:
			self.write("You are the best ever!")
		else:
			self.write("You've been %s times!" % visits)

- So now the user can only "fake" their visits if they know what hash we're using!

- But what if they know what hash we're using?
	- We need an extra secret!
		- instead of just:
		H(1) = [HASH]
		- we can:
		H(SECRET+1) = [HASH]
		- Now if they don't know our secret, it's going to be super hard for them to break our hash!

- Another note:
	- so far we've been using the Python library:
		hashlib
	- but even better is:
		HMAC
			- which stands for "Hash-based Message Authentication Code"
			- it's a special algorithm for adding these keys/secrets into hashes easily
	- We use it something like this:
		hmac(secret, key, hash_function)

- Using hmac in console:
python
hmac.new("secret", "udacity").hexdigest()

- To make our old code switch to hmac
import hmac
SECRET = 'imsosecret'
def hash_str(s):
	return hmac.new(SECRET, s).hexdigest()





# Left off at Lesson 4 > Incorporating Hmac (~70% through)