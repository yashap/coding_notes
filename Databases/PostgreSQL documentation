# Typically want a separate db for each project, for each user
# To create a db
createdb mydb

# log in
psql mydb

# if you're a normal user you'll see:
mydb=>
# if you're the db superuser, you'll see
mydb=#

# Some sample queries
SELECT verison();
SELECT current_date;
SELECT 2+2;

# Internal commands
\h			# help with commands
					# i.e. \h SELECT
\q			# quit
\?			# more internal commands
\i file.sql		# reads in SQL commands from a sql file

# Tables
# 	Columns have a fixed order in each row
# 	Rows DO NOT have a guaranteed order, though they can be sorted for display

# Tables are grouped into databases
# 	A collection of dbs managed by a single PostgreSQL server instance constitutes a database cluster

# Creating a new table
# 	Use the following syntax
CREATE TABLE weather (
    city            varchar(80),
    temp_lo         int,           -- low temperature
    temp_hi         int,           -- high temperature
    prcp            real,          -- precipitation
    date            date
);
CREATE TABLE cities (
    name            varchar(80),
    location        point
);
# Note how both comments (--) and whitesapce (spaces or dashes) are ignored
# SQL is case insensitive about keywords and identifiers, EXCEPT when double-quoted to preserve case (not done above)
# Can also drop tables like this:
DROP TABLE cities;

# PostgreSQL types
int
smallint
real
double precision
char(N)
varchar(N)
date
time
timestamp
interval
# Also a bunch of other general utility types
# And a rich set of geometric types
# AND you can define your own data types
# Because of this, types ARE NOT keywords, except in specific cases where they need to be

# Populating a table with rows
INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');
# Check
SELECT * FROM WEATHER;

# Another example
INSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');
SELECT * FROM cities;

# Some notes:
# 	Everything that's not a simple numeric value must be surrounded by single quotes (even dates, points, etc.)
# 	point accepts coordinate pairs

# You can also explicitly say which data to insert into which columns
# 	This way you don't have to remember the order of columns
# 	You also don't have to enter NULL values, but you can if you want
INSERT INTO weather (date, city, temp_hi, temp_lo)
	VALUES ('1994-11-29', 'Hayward', 54, 37);
INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)
	VALUES ('San Francisco', 43, 57, NULL,'1994-11-29');
SELECT * FROM weather;

# Then to alter data:
UPDATE weather SET (prcp, temp_hi) = (0, 58)
	WHERE city = 'San Francisco' AND date = '1994-11-29';

# You can also insert data from flat text files, for example:
COPY weather FROM '/home/user/weather.txt';
# The source file must be stored on the machine running psql, not on the client
# Read more about COPY here:
http://www.postgresql.org/docs/9.3/interactive/sql-copy.html


############
# Basic queries
############

SELECT city, temp_lo, temp_hi, date FROM weather;

SELECT city, (temp_lo + temp_hi)/2 AS temp_avg, date FROM weather;

SELECT * FROM weather
	WHERE city = 'San Francisco' and prcp > 0.0;

SELECT * FROM weather
	ORDER BY city, temp_lo;

SELECT DISTINCT city
	FROM weather
	ORDER BY city;


############
# Joins
############

SELECT *
	FROM weather, cities
	WHERE city = name;
# What will this return?
# 	1) It'll be an INNER JOIN, won't include cities that aren't in both tables
# 	2) It'll have both the city and name fields (duplicate info)
# 		Can "fix" this by explicitly specifying columns
SELECT city, temp_lo, temp_hi, prcp, date, location
	FROM weather, cities
	WHERE city = name;
# It's even better form to state what table everything is coming from
SELECT weather.city, weather.temp_lo, weather.temp_hi, weather.prcp, weather.date, cities.location
	FROM weather, cities
	WHERE cities.name = weather.city;

# Other join syntax
SELECT *
	FROM weather
	INNER JOIN cities ON (weather.city = cities.name);

# Or, if we want all cities in the weather table
SELECT *
	FROM weather
	LEFT OUTER JOIN cities ON (weather.city = cities.name);

# Self joins
# 	For example, let's say we want to find all cities with temperature ranges that that fall completely within anther city's temp range
SELECT W1.city AS outer_city,
	W1.temp_lo AS outer_low,
	W1.temp_hi AS outer_high,
	W2.city AS inner_city,
	W2.temp_lo AS inner_low,
	W2.temp_hi AS inner_high
FROM weather W1, weather W2
WHERE W1.temp_lo < W2.temp_lo
	AND W1.temp_hi > W2.temp_hi;


############
# Aggregate functions
############

SELECT MAX(temp_lo) FROM weather;
# 46

# But what if we want to know what city, or cities, that max temp occurs in?
SELECT city
FROM weather
WHERE temp_lo = (
	SELECT MAX(temp_lo)
	FROM weather
);
# San Francisco
# Note the use of nesting
# 	Need to find the max temp first, then can find the cities

# Aggregates also go great with GROUP BY
SELECT city,
	MAX(temp_lo)
FROM weather
GROUP BY city
HAVING MAX(temp_lo) < 40;

# Note the use of HAVING
# 	Similar to a WHERE clause
# 	With a WHERE clause only the rows with temp_lo < 40 would be included
# 	But if one city occurs multiple times, sometimes with temp_lo below and sometimes above 40, the WHERE clause won't exclude the city
# 	HAVING will exclude the city, it filters for cities that ONLY have temp_lo values below 40

# More on HAVING vs. WHERE
# 	1) WHERE selects rows before the groups/aggregates are computed, while HAVING selects rows after groups and aggregates are computed
# 	2) HAVING should really only be used with groups/aggregates
# 	3) Sometimes you can use either - use WHERE in that case, as it's more efficient (filtering out rows before aggregating means less work to aggregate)





# Left off at:

http://www.postgresql.org/docs/9.3/interactive/tutorial-update.html

[start]